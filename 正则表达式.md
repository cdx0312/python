#正则表达式

字符串是编程时涉及到最多的一种数据结构，对于字符串进行操作的需求几乎无处不在。比如判断一个字符串是否是合法的Email地址，虽然可以编程提取@前后的子串，再分别判断是否是单词和域名，但这样做不但麻烦，而且代码难以复用。

正则表达式是一种用来匹配字符串的强有力的武器。它设计的思想是用一种描述性的语言来给字符串定义了一个规则，凡是符合规则 对字符串，我们就认为它匹配了，否则，该字符串就是不合法的。

所以我们判断一个字符串是否是合法的Email的方法是：
1、创建一个匹配Email的正则表达式
2、用该正则表达式去匹配用户的输入来判断是否合法。

因为正则表达式也是用字符串表示的，首先需要了解如何用字符来描述字符。

在正则表达式中，如果直接给出字符，就是精确匹配。用`\d`可以匹配一个数字，`\w`可以匹配一个字母或数字，所以：
>`00\d`可以匹配`007`，但是无法匹配`00A`
>`\d\d\d`可以匹配`010`
>`\w\w\d`可以匹配`py3`
>`.`可以匹配任意字符，`py.`可以匹配`pyc``py0``py!`等。

要匹配变长的字符，在正则表达式中，用`*`表示任意个字符，用`+`表示至少一个字符，用`?`表示0个或1个字符，用`{n}`表示n个字符，用`{n,m}`表示n-m个字符：

`\d{3}\s+\d{3,8}`
1、`\d{3}`表示匹配三个数字
2、`\s`表示可以匹配一个空格（包括Tab等空白符），`\s+`表示至少有一个空白符，
3、`\d{3.8}`表示3-8个数字。
综合起来，上面的正则表达式可以匹配任意个空格隔开的带区号的电话号码。如果要匹配`010-12345`这样的号码时，由于`-`是特殊字符，在正则表达式中要用`\`转义，所以上面的正则为：`\d{3}\-\d{3,8}`，但是仍然无法匹配`010 - 12345`这样的电话号码。

##进阶

要做更精确的匹配，可以用`[]`表示范围：
>`[0-9a-zA-Z\_]`可以匹配一个数字、字母或者下划线
>`[0-9a-zA-Z\_]+`可以匹配至少由一个数字、字母或者下划线组成的祖字符串，比如`a100`，`0_z`，`Py300`等
>`[a-zA-z\_][0-9a-zA-Z\_]*`可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串。
>`[a-zA-z\_][0-9a-zA-Z\_]{0,19}`更精确地限制了变量的长度是1-20个字符

`A|B`可以匹配A或B，所以`(P|p)ython`可以匹配`python`或者`Python`。

`^`表示行的开头，`^\d`表示必须以数字开头。

`$`表示行的结束，`\d$`表示必须以数字结束。

##re模块

Python提供`re`模块，包含所有正则表达式的功能。又有Python的字符串本身也用`\`转义，要特别注意：
```python
>>> s='ABC\\-001'
#python的字符串，对应的正则表达式'ABC\-001'
>>> s=r'ABC\-001'
#加r就不再考虑转义的问题
```
如何判断正则表达式是否匹配：
```python
>>> import re
>>> re.match(r'^\d{3}\-\d{3,8}$', '010-12345')
<_sre.SRE_Match object; span=(0, 9), match='010-12345'>
>>> re.match(r'^\d{3}\-\d{3,8}$', '010 12345')
```

`match()`方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。常见的判断方法是：
```python
test='用户输入的字符串'
if re.match(r'正则表达式',est):
	print('ok')
else:
	print('failed')
```

##切分字符串

用正则表达式切分字符串比用固定的字符更灵活，正常的切分代码为：
```python
>>> 'a b    c'.split()
['a', 'b', 'c']
```
无法识别连续的空格，用正则表达式：
```python
>>> re.split(r'\s+','a b   c')
['a', 'b', 'c']
```
无论多少个空格都可以正常分割。加入`,`：
```python
>>> re.split(r'[\s\.]+','a, b, c d')
['a,', 'b,', 'c', 'd']
```
加入`;`：
```python
>>> re.split(r'[\s\.\;]+','a,b;; c d')
['a,b', 'c', 'd']
```

##分组
除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用`()`表示的就是要提取的分组。比如：

`^(\d{3}-(\d{3,8}))$`分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：
```python
>>> m=re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
>>> m
<_sre.SRE_Match object; span=(0, 9), match='010-12345'>
>>> m.group(0)
'010-12345'
>>> m.group(1)
'010'
>>> m.group(2)
'12345'
```

如果正则表达式中定义了组，就可以在`Match`对象上用`group()`方法提取出子串来。

`group(0)`永远是原始字符串，`group(1)`、`group(2)`......表示第一个、第二个子串。

提取子串很有用：
```python
>>> t='19:13:12'
>>> m = re.match(r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$', t)
>>> m.groups()
('19', '13', '12')
```
这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：
>'^(0[1-9]|1[0-2]|[0-9])-(0[0-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$'

对于`2-30`，`4-31`这样的非法日期，用正则还是识别不了。

##贪婪匹配

正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。如匹配出数字后面的0：
```python
>>> re.match(r'^(\d+)(0*)$','102300').groups()
('102300', '')
```

由于`\d+`采用贪婪匹配，直接把后面的0全匹配了，结果`0*`只能匹配空字符串了。

必须让`\d+`采用非贪婪匹配，才能把后面的0匹配出来，加个`？`就可以了：
```python
>>> re.match(r'^(\d+?)(0*)$','102300').groups()
('1023', '00')
```

##编译

当我们在Python中使用正则表达式时，re模块会做两件事情：
>1、编译正则表达式，如果正则表达式的字符串本身不合法会报错。
>2、用编译后的正则表达式去匹配字符串

如果一个正则表达式要重复机器那次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：
```python
>>> import re
>>> re_telephone=re.compile(r'^(\d{3})-(\d{3,8})$')
>>> re_telephone.match('010-12345').groups()
('010', '12345')
>>> re_telephone.match('010-8989').groups()
('010', '8989')
```
编译后生成Regular Expression对象，由于该对象自己包含了正则表达式，所以调用对应的方法时不用给出正则字符串。

